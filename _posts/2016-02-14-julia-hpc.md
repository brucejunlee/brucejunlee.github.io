---
layout: post
title: "Julia编程(三): 高性能计算"
author: "李军"
categories: journal
tags: [Julia, HPC]
image:
  feature: juliabasics.jpg
  teaser: juliabasics-teaser.jpg
  credit:
  creditlink:
---

本文是Julia编程系列的第三篇文章，着重讲述它在高性能计算方面的应用。

## 引言

## 语言分析[^1]

### Profiling

Julia中自带`Profile`包，实现了所谓的采样(sampling)或统计分析(statistical profiler)。在任务执行期间，它通过周期性地回溯(backtrace)来工作。每次回溯捕获当前运行的函数和行号，以及导致这行的完整函数调用链，因此这是当前执行状态的一个快照。一个统计分析软件并不提供完整的逐行覆盖，因为回溯是在一定时间段发生的，默认情况下，Unix系统为1ms，Windows系统为10ms。并且采样是在所有执行点的一个稀疏子集上进行的，因此这样的数据具有一定的统计噪声。

```julia
function myfunc()  A = rand(100, 100, 200) 
  maximum(A)  # expensiveend

@profile myfunc()
Profile.print()

@profile (for i = 1:100; myfunc(); end)
Profile.print()  # default "tree" dump

Profile.print(format=:flat)
```

代码中存在递归

```julia
dumbsum(n::Integer) = n == 1 ? 1 : 1 + dumbsum(n-1)dumbsum3() = dumbsum(3)
@profile dumbsum3()
Profile.print()
```

#### 累积(accumulation)&清除

@profile产生的结果都累积在一个缓冲区中，如果在@profile下运行多个代码块，那么Profile.print()将显示组合结果。我们可以调用`Profile.clear()`刷新缓冲区。

print参量说明

```julia
function print(io::IO = STDOUT, data = fetch(); format = :tree, C = false, combine = true, cols = tty, maxdepth, sortedby = :count, noisefloor, mincount)
```

```julia
data = copy(Profile.fetch())Profile.clear()@profile Profile.print(STDOUT, data) # Prints the previous results 
Profile.print() # Prints results from Profile.print()
```

```julia
s = open("/tmp/prof.txt","w")Profile.print(s, cols = 500)
close(s)
```

#### 配置

```julia
Profile.init() # returns the current settings
Profile.init(n, delay)  #default n = 10^6, delay = 0.001Profile.init(delay = 0.01)
```

### 内存分配分析

减少内存分配是一种最常见的提升性能的技术。分配总数可以通过`@time`和`@allocated`来估量，特定的触发分配的行可以通过Profiling中由这些行引起的垃圾回收(garbage collection)代价推理出来。当然这也可以直接通过代码每一行分配的内存量测量出来。

```shell
$ julia  --track-allocation=<setting>
```

这里的`<setting>`选项包括`none`, `user`和`all`。

当退出Julia时，结果被写入相同目录下的`.mem`文件中。`Coverage`包包含一些基本分析工具，如按分配字节数的顺序将行进行排序。

### Stack Traces

```julia
stacktrace()

example() = stacktrace()
example()

@noinline child() = stacktrace()
@noinline myparent() = child()  # avoid Base.parent
grandparent() = myparent()
grandparent()
```

#### 信息抽取

```julia
top_frame = stacktrace()[1]
top_frame.func
top_frame.file
top_frame.line
top_frame.linfo
top_frame.inlined
top_frame.from_c
top_frame.pointer
```

#### 错误处理

```julia
@noinline bad_function() = undeclared_variable

@noinline example() = try 
  bad_function()catch
  stacktrace()end

example()

@noinline example() = try 
  bad_function()catch
  catch_stacktrace()end

example()
```

```julia
@noinline child() = error("Whoops!")
@noinline myparent() = child()
@noinline function grandparent() 
  try    myparent() 
  catch err
    println("ERROR: ", err.msg)
    catch_stacktrace()  end
end

grandparent()
```

#### 比较

+ backtrace()返回Ptr{Void}向量

```julia
trace = backtrace()
stacktrace(trace)
```

+ 默认情况下，stacktrace()从stack栈中移除了低级C函数

```julia
stacktrace(trace, true)
```

```julia
pointer = backtrace()[1]
frame = StackTraces.lookup(pointer)
println("The top frame is from $(frame[1].func)!")
```

### 性能提升的技巧

#### 避免全局变量

+ 任何性能攸关或作为基准的代码都应该放置在函数中
+ 置为常量

	```julia
 	const DEFAULT_VAL = 0
	```
+ 声明类型

	```julia
	global x
	y = f(x::Int + 1)
	```
+ REPL中的所有代码都处于全局作用域

#### 用`@time`评估性能&关注内存分配

`@time`不同于`tic()``toc()`函数，它除了输出花费时间外还输出占用内存。

```julia
function f(n)
  s=0  for i = 1:n
    s += i/2
  end  send

@time f(1)
@time f(10^6)
```

#### 工具

关于第三方包更具体的使用，请看下面第二部分。

+ Profiling
+ ProfileView包：用于复杂项目
+ @code_warntype
+ Lint包
+ TypeCheck包

#### 避免带抽象类型参量的容器

```julia
a = Real[] # typeof(a) = Array{Real,1} 
if (f = rand()) < .8  push!(a, f)end
```

因为a是Real抽象类型的数组，所以它必须要能够承载任意Real值。Real对象是任意大小和任意结构的，所以a必须表示成指向单独分配的Real对象的指针数组。因为f是Float64类型的，所以`a = Float64[]`更好。
这将创建可以高效操纵的64位浮点数值的连续块，这在系列文章的第一篇入门中也经常提到。

#### 类型声明

##### 避免抽象类型的域

```julia
type MyAmbiguousType 
  aend
b = MyAmbiguousType("Hello")
c = MyAmbiguousType(17)
typeof(b)
typeof(c)
```

编译器使用对象类型而不是值来确定如何构建代码，但是从对象中编译器并不能推出有用信息。下面的b和c具有相同类型，但是它们在内存中的基本数据表示是有很大不同的。即使你在域a中存储数值，UIint8和Float64类型的数值在内存中的表示仍然不同，因此CPU需要使用两种不同的指令来处理它们。因为所需信息在下面的type中不能获知，因此这样的决策需要在运行时进行。

```julia
type MyType{T<:AbstractFloat} 
  a::Tend
m = MyType(3.2)
typeof(m)

m.a = 4.5f0
typeof(m.a)  # not change
```

```julia
func(m::MyType) = m.a + 1
code_llvm(func,(MyType{Float64},)) 
code_llvm(func,(MyType{AbstractFloat},))
code_llvm(func, (MyType, ))
```

##### 避免抽象容器的域

```julia
type MySimpleContainer{A<:AbstractVector} 
  a::Aend
c = MySimpleContainer(1:3)
typeof(c)
c = MySimpleContainer([1:3;])
typeof(c)
```



##### 声明取自无类型位置处的值


##### 声明关键字参量的类型


#### 将函数拆成多个定义


## 第三方包的使用
High Performance Computing[^2]

[^1]: Jeff Bezanson, Stefan Karpinski, Viral Shah, Alan Edelman, et al., Julia Language Documentation(Release 0.6.0-dev).
[^2]: Avik Sengupta, Julia High Performance, 2016.